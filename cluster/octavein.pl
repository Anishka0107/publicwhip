#! /usr/bin/perl -w 
use strict;

# $Id: octavein.pl,v 1.1 2003/08/14 19:35:48 frabcus Exp $
# Outputs a matrix of distances between pairs of MPs for
# use by the GNU Octave script mds.m to do clustering.

# The Public Whip, Copyright (C) 2003 Francis Irving and Julian Todd
# This is free software, and you are welcome to redistribute it under
# certain conditions.  However, it comes with ABSOLUTELY NO WARRANTY.
# For details see the file LICENSE.html in the top level of the source.

use POSIX qw(strftime);
my $now_string = strftime "%a %b %e %H:%M:%S %Y", localtime;
print "# Autogenerated by octavein.pl from The Public Whip project on $now_string\n\n";

require "../scraper/db.pm";
my $dbh = db::connect();

# Count MPs (which have voted at least once)
require "mpquery.pm";
my @mp_ixs = mpquery::get_mp_ixs($dbh);

# Count divisions
my $sth = db::query($dbh, "select division_id from pw_division");
my @div_ixs;
while (my @data = $sth->fetchrow_array())
{
    push @div_ixs, $data[0];
}

# Read all votes in, and make array of MPs and their vote in each division
$sth = db::query($dbh, "select division_id, mp_id, vote from pw_vote order by mp_id, division_id");
my @votematrix;
while (my @data = $sth->fetchrow_array())
{
    my ($div_dat, $mp_dat, $vote) = @data;
    my $votescore = undef;
    $votescore = 1 if ($vote eq "aye");
    $votescore = -1 if ($vote eq "noe");
    die "Unexpected $vote voted" if (!defined $votescore);
    
    $votematrix[$mp_dat][$div_dat] += $votescore;
}

# Create matrix of "distances" between MPs
my @metricD;
for my $mp_1 (@mp_ixs)
{
    for my $mp_2 (@mp_ixs)
    {
        # For the pair of MPs, tot up which divisions they voted the same in
        my $divs_both_at = 0;
        my $divs_voted_same = 0;
        for my $div_ix (@div_ixs)
        {
            my $vote1 = $votematrix[$mp_1][$div_ix];
            my $vote2 = $votematrix[$mp_2][$div_ix];
            $vote1 = 0 if (!defined $vote1);
            $vote2 = 0 if (!defined $vote2);
            if ($vote1 != 0 and $vote2 != 0)
            {
                $divs_both_at++;
                if ($vote1 == $vote2)
                {
                    $divs_voted_same++;
                }
            }
        } 

        # Create score based on this
        if ($divs_both_at != 0)
        {
            $metricD[$mp_1][$mp_2] = ($divs_both_at - $divs_voted_same) / $divs_both_at;
        }
        elsif ($mp_1 == $mp_2)
        {
            $metricD[$mp_1][$mp_2] = 0; # No-voters, like Gerry Adams need this clause
        }
        else
        {
            $metricD[$mp_1][$mp_2] = 1;
        }
    }
}

# Print it all out
for my $mp_1 (@mp_ixs)
{
    my $sthmp = db::query($dbh, "select last_name, first_name, party from pw_mp where mp_id=?", $mp_1);
    die "Wrong number of rows back" if $sthmp->rows != 1;
    my @data = $sthmp->fetchrow_array();
    my ($lastname, $firstname, $party) = @data; 

    print "na" . $mp_1 . " = \"" . $lastname . ", " . $firstname . "\";\n";
    print "pa" . $mp_1 . " = \"" . $party . "\";\n";
    print "r" . $mp_1 . " = [";
    for my $mp_2 (@mp_ixs)
    {
        print "," if ($mp_2 != $mp_ixs[0]);
        print $metricD[$mp_1][$mp_2];
    }
    print "];\n";
}

print "D=[\n";
foreach my $mp_ix (@mp_ixs)
{
    print "r" . $mp_ix . ";";
}
print "];\n";

print "ns=[\n";
for my $mp_ix (@mp_ixs)
{
    print "na" . $mp_ix . ";";
}
print "];\n";

print "ps=[\n";
for my $mp_ix (@mp_ixs)
{
    print "pa" . $mp_ix . ";";
}
print "];\n";


